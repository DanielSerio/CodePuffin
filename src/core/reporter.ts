import pc from 'picocolors';
import path from 'path';
import { mkdirSync, writeFileSync } from 'fs';
import { RuleResult } from './rules';
import { Config } from './config';

export function reportStylish(results: RuleResult[], root: string) {
  if (results.length === 0) {
    console.log(pc.green('\n‚úî No issues found!'));
    return;
  }

  const grouped = results.reduce((acc, result) => {
    if (!acc[result.file]) acc[result.file] = [];
    acc[result.file].push(result);
    return acc;
  }, {} as Record<string, RuleResult[]>);

  console.log(pc.red(`\n‚úñ Found ${results.length} issues:\n`));

  for (const [file, fileResults] of Object.entries(grouped)) {
    const relativeFile = path.relative(root, file);
    console.log(pc.underline(pc.white(relativeFile)));

    for (const res of fileResults) {
      const color = res.severity === 'error' ? pc.red : pc.yellow;
      const label = res.severity.toUpperCase();
      console.log(`  ${color(label.padEnd(7))} ${res.message} ${pc.gray(res.ruleId)}`);
    }
    console.log('');
  }
}

// Computes summary counts from results
function summarize(results: RuleResult[]) {
  const errors = results.filter(r => r.severity === 'error').length;
  const warnings = results.filter(r => r.severity === 'warn').length;
  return { total: results.length, errors, warnings };
}

// Returns pretty-printed JSON report with summary and relative file paths
export function reportJson(results: RuleResult[], root: string): string {
  const summary = summarize(results);

  const mappedResults = results.map(r => {
    const entry: Record<string, unknown> = {
      ruleId: r.ruleId,
      file: path.relative(root, r.file).replace(/\\/g, '/'),
    };
    // Only include line when defined
    if (r.line !== undefined) {
      entry.line = r.line;
    }
    entry.message = r.message;
    entry.severity = r.severity;
    return entry;
  });

  return JSON.stringify({ summary, results: mappedResults }, null, 2);
}

// Returns Markdown report optimized for human developers and AI coding agents
export function reportMarkdown(results: RuleResult[], root: string): string {
  const summary = summarize(results);
  const lines: string[] = [];

  lines.push('# üêß CodePuffin Scan Report');
  lines.push('');
  lines.push('## ü§ñ Agent Mission');
  lines.push('You are an AI developer tasked with resolving architectural and style violations. Use the report below to identify, locate, and fix the issues.');
  lines.push('');
  lines.push('### üìÇ Project Context');
  lines.push(`- **Root Directory**: \`${root}\``);
  lines.push(`- **Scan Date**: ${new Date().toLocaleString()}`);
  lines.push('');
  lines.push('### üìä Summary');
  lines.push(`**Total Issues**: ${summary.total}`);
  lines.push(`- **Errors**: ${summary.errors}`);
  lines.push(`- **Warnings**: ${summary.warnings}`);
  lines.push('');

  if (results.length === 0) {
    lines.push('‚ú® **Great job! No issues found.**');
    return lines.join('\n');
  }

  lines.push('## üõ†Ô∏è Issues');
  lines.push('');
  lines.push('| File Path | Line | Severity | Rule | Message | Suggested Action | Resolved |');
  lines.push('| :--- | :--- | :--- | :--- | :--- | :--- | :---: |');

  for (const r of results) {
    const rel = path.relative(root, r.file).replace(/\\/g, '/');
    const line = r.line !== undefined ? `[L${r.line}]` : '-';
    const severity = r.severity === 'error' ? 'üî¥ **ERROR**' : 'üü° WARN';
    const suggestion = r.suggestion || 'N/A';
    lines.push(`| \`${rel}\` | ${line} | ${severity} | \`${r.ruleId}\` | ${r.message} | *${suggestion}* | - [ ] |`);
  }

  lines.push('');
  lines.push('*Report generated by CodePuffin.*');

  return lines.join('\n');
}

// Writes a report file based on the configured output format
export function writeReportFile(config: Config, results: RuleResult[], root: string) {
  const { format, reportFile: configuredFile } = config.output;
  if (format === 'stylish') return;

  let fileName = configuredFile;

  // Rule: For markdown and json, ensure they go into 'reports' directory if no path specified
  if (format === 'markdown' || format === 'json') {
    if (!fileName) {
      fileName = format === 'markdown' ? 'reports/puffin-report.md' : 'reports/puffin-report-[timestamp].json';
    } else if (!fileName.includes('/') && !fileName.includes('\\')) {
      fileName = `reports/${fileName}`;
    }
  }

  if (!fileName) return;

  const formatter = format === 'markdown' ? reportMarkdown : reportJson;
  const content = formatter(results, root);

  // Replace [timestamp] if present (only for JSON reports to keep Markdown reports stable)
  let finalFileName = fileName;
  if (format === 'json' && finalFileName.includes('[timestamp]')) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    finalFileName = finalFileName.replace('[timestamp]', timestamp);
  }

  const filePath = path.resolve(root, finalFileName);

  try {
    mkdirSync(path.dirname(filePath), { recursive: true });
    writeFileSync(filePath, content, 'utf-8');
    console.log(pc.green(`\nüìù Report written to ${pc.bold(finalFileName)}`));
  } catch (err: any) {
    console.warn(pc.yellow(`\n‚ö†Ô∏è Failed to write report file: ${err.message}`));
  }
}
